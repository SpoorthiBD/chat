import torch
import torchvision.transforms as transforms
from PIL import Image

# Function to load the pretrained Pix2Pix model
def load_pix2pix_model(model_path):
    model = None
    try:
        model = torch.load(model_path, map_location=torch.device('cpu'))
        model.eval()  # Set model to evaluation mode
    except Exception as e:
        print(f"Error loading model from {model_path}: {e}")
    return model

# Example usage
if __name__ == "__main__":
    model_path = 'path_to_downloaded_pix2pix_model.pth'  # Replace with your actual downloaded model path
    
    # Load Pix2Pix model
    pix2pix_model = load_pix2pix_model(model_path)
    
    if pix2pix_model is None:
        print(f"Failed to load Pix2Pix model from {model_path}. Please check the file path.")
    else:
        print(f"Pix2Pix model loaded successfully from {model_path}.")
        
        # Example: Apply the model to an input image
        input_image_path = 'path_to_input_image.jpg'  # Replace with your input image path
        input_image = Image.open(input_image_path).convert('RGB')

        transform = transforms.Compose([
            transforms.Resize((256, 256)),  # Resize image to fit Pix2Pix model input size
            transforms.ToTensor(),
            transforms.Normalize(mean=[0.5, 0.5, 0.5], std=[0.5, 0.5, 0.5])  # Normalize image
        ])

        input_tensor = transform(input_image).unsqueeze(0)  # Add batch dimension
        with torch.no_grad():
            output_tensor = pix2pix_model(input_tensor)  # Forward pass

        # Convert output tensor to image format and save or display it
        output_image = transforms.ToPILImage()(output_tensor.squeeze(0).cpu())
        output_image.save('output_image_pix2pix.jpg')  # Save the output image
        output_image.show()  # Display the output image
